<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minimalist FPS Game - Fixed Version</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 10px;
      font-family: monospace;
    }
    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 20px;
      text-align: center;
      font-family: monospace;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div id="ui">Health: 100<br>XP: 0<br>Level: 1<br>Coins: 0<br>Sword: Grey Blade</div>
<div id="instructions">Click to Play</div>
<script src="https://unpkg.com/three@0.136.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.136.0/examples/js/controls/PointerLockControls.js"></script>
<script>
  let scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);

  let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.y = 1.6;

  let renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.PointerLockControls(camera, document.body);

  const instructions = document.getElementById('instructions');

  instructions.addEventListener('click', () => {
    controls.lock();
  });

  controls.addEventListener('lock', () => {
    instructions.style.display = 'none';
  });

  controls.addEventListener('unlock', () => {
    instructions.style.display = '';
  });

  // Movement variables
  const keys = {};

  document.addEventListener('keydown', (event) => {
    keys[event.code] = true;
  });

  document.addEventListener('keyup', (event) => {
    keys[event.code] = false;
  });

  // Ground
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(200, 200),
    new THREE.MeshLambertMaterial({ color: 0x228B22 })
  );
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  // Light
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(50, 100, 50);
  scene.add(light);

  // Tree function
  function createTree(x, z) {
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.2, 0.2, 1),
      new THREE.MeshLambertMaterial({ color: 0x8B4513 })
    );
    trunk.position.set(x, 0.5, z);

    const leaves = new THREE.Mesh(
      new THREE.SphereGeometry(0.8),
      new THREE.MeshLambertMaterial({ color: 0x006400 })
    );
    leaves.position.set(x, 1.6, z);

    scene.add(trunk);
    scene.add(leaves);
  }

  // Rock function
  function createRock(x, z) {
    const rock = new THREE.Mesh(
      new THREE.DodecahedronGeometry(0.5),
      new THREE.MeshLambertMaterial({ color: 0x555555 })
    );
    rock.position.set(x, 0.25, z);
    scene.add(rock);
  }

  // Populate world
  for (let i = 0; i < 100; i++) {
    let x = (Math.random() - 0.5) * 180;
    let z = (Math.random() - 0.5) * 180;
    if (Math.random() > 0.5) createTree(x, z);
    else createRock(x, z);
  }

  // Border decoration (circle of rocks)
  const radius = 90;
  for (let i = 0; i < 60; i++) {
    let angle = (i / 60) * Math.PI * 2;
    let x = Math.cos(angle) * radius;
    let z = Math.sin(angle) * radius;
    createRock(x, z);
  }

  // Sword
  const sword = new THREE.Mesh(
    new THREE.BoxGeometry(0.05, 1.2, 0.1),
    new THREE.MeshLambertMaterial({ color: 0x888888 })
  );
  sword.position.set(0.3, -0.3, -1);
  camera.add(sword);
  scene.add(camera);

  // Animate
  const clock = new THREE.Clock();
  let velocity = new THREE.Vector3();
  let direction = new THREE.Vector3();

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    direction.z = Number(keys['KeyW']) - Number(keys['KeyS']);
    direction.x = Number(keys['KeyD']) - Number(keys['KeyA']);
    direction.normalize();

    if (keys['KeyW'] || keys['KeyS']) velocity.z -= direction.z * 400.0 * delta;
    if (keys['KeyA'] || keys['KeyD']) velocity.x -= direction.x * 400.0 * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
